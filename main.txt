# !/usr/bin/env python3

#!/usr/bin/env python3

# Main.py file generated by New Project wizard

# Created:   T4 Thg7 7 2021
# Processor: RPI3
# Compiler:  Python 3 (Proteus)

# Modules
from goto import *
import time
import var
import pio
import resource
from pymodbus.client.sync import ModbusSerialClient

import RPi.GPIO as GPIO
import time
import serial
GPIO.setmode(GPIO.BCM)
start_address_coil = 0
start_address_discrete_input = 0
start_address_input_registers = 0
start_address_holding_registers = 0
count_coil = 10
count_discrete_input = 10
count_input_registers = 10
count_holding_registers = 10
# Peripheral Configuration Code (do not edit)
#---CONFIG_BEGIN---
import cpu
import FileStore
import VFP

def peripheral_setup () :
# Peripheral Constructors
 pio.cpu=cpu.CPU ()
 pio.storage=FileStore.FileStore ()
 pio.server=VFP.VfpServer ()
 pio.storage.begin ()
 pio.server.begin (0)
# Install interrupt handlers

def peripheral_loop () :
 pio.server.poll ()

#---CONFIG_END---

# Main function
client = ModbusSerialClient(method= "rtu", port="COM1", stopbits=1, bytesize=8, parity="N", baudrate=9600)
client.connect()
ser = serial.Serial(port = 'COM3', baudrate = 9600, parity = serial.PARITY_NONE,
                    stopbits = serial.STOPBITS_ONE, bytesize = serial.EIGHTBITS, timeout = 1)


class read():
    # return string data
    def __init__(self,unit):
        self.unit = unit
    def read_coil(self, start_address, count):
        data = client.read_coils(address=start_address, count=count, unit=self.unit)
        return str(data.bits)

    def read_discrete_input(self, start_address, count):
        data = client.read_discrete_inputs(address=start_address, count = count, unit = self.unit)
        return str(data.bits)

    def read_input_registers_int(self, start_address, count):
        data = client.read_input_registers(address= start_address, count = count, unit = self.unit)
        return str(data.registers)

    def read_input_registers_float(self, start_address, count):
        # make sure count is even number
        try:
            data = client.read_input_registers(address= start_address, count = count, unit = self.unit)
            data_int16 = np.array(data.registers, dtype = np.int16)
            return str(list(data_int16.view(dtype = np.float32)))
        except ValueError:
            print("Make sure count(ead_input_registers_float) is even number")

    def read_holding_registers_int(self, start_address, count):
        data = client.read_holding_registers(address=start_address, count=count, unit = self.unit)
        return str(data.registers)

    def read_holding_registers_float(self, start_address, count):
        try:
            data = client.read_holding_registers(address= start_address, count = count, unit = self.unit)
            data_int16 = np.array(data.registers, dtype = np.int16)
            return str(list(data_int16.view(dtype = np.float32)))
        except ValueError:
            print("Make sure count(read_holding_registers_float) is even number")

class write():
    def __init__(self, unit):
        self.unit = unit
    def write_coil(self, address, value):
        client.write_coil(address=address, value= value, unit= self.unit)
    def write_register_int(self, address, value):
        client.write_register(address=address, value=value, unit = self.unit)
    def write_register_float(self, address, value):
        arr_int = self.float_to_array_int(fl = value)
        print(arr_int)
        self.write_holding_int_array_to_float(arr = arr_int,address=address, unit= self.unit)

    def float_to_array_int(self,fl):
        # input = float
        # output = array int
        return list(np.array([fl], dtype=np.float32).view(dtype=np.int16))

    def write_holding_int_array_to_float(self,arr, address, unit):
        client.write_register(address=address, value=arr[0], unit=unit, skip_encode = True)
        client.write_register(address=address+1, value=arr[1], unit=unit, skip_encode = False)
# set init
start_address_coil = 0
start_address_discrete_input = 0
start_address_input_registers = 0
start_address_holding_registers = 0
count_coil = 10
count_discrete_input = 10
count_input_registers = 10
count_holding_registers = 10
type_ = "Int"
data_input_registers = ""
data_holding_registers = ""

while True:
    recv = ser.readline()
    data_recv = recv.decode().rstrip()

    if (data_recv.split('-')[0] == 'read' or data_recv.split('-')[0] == 'write'):
        data_split = data_recv.split('-')
        if data_split[-1] == 'Int':
            type_ = 'Int'
        if data_split[-1] == 'Float':
            type_ = 'Float'

        if data_split[0] == "read":
            start_address_coil = int(data_split[1])
            start_address_discrete_input = int(data_split[3])
            start_address_input_registers = int(data_split[5])
            start_address_holding_registers = int(data_split[7])
            count_coil = int(data_split[2])
            count_discrete_input = int(data_split[4])
            count_input_registers  = int(data_split[6])
            count_holding_registers = int(data_split[8])

        else:
            address_coil_write = int(data_split[1])
            values_coil_write = int(data_split[2])
            address_holding_write = int(data_split[3])
            write_ = write(unit=1)
            write_.write_coil(address=address_coil_write, value=values_coil_write)
            if data_split[-1] == "Int":
                values_holding_write = int(data_split[4])
                write_.write_register_int(address=address_holding_write, value=values_holding_write)
            else: # float
                values_holding_write = float(data_split[4])
                write_.write_register_float(address=address_holding_write, value= values_holding_write)

    read_ = read(unit=1)
    data_coil = read_.read_coil(start_address=start_address_coil, count=count_coil)
    data_discrete_input = read_.read_discrete_input(start_address= start_address_discrete_input, count= count_discrete_input)
    if type_ == 'Int':
        data_input_registers = read_.read_input_registers_int(start_address= start_address_input_registers, count= count_input_registers)
        data_holding_registers = read_.read_holding_registers_int(start_address= start_address_holding_registers, count= count_holding_registers)
    if type_ == 'Float':
        data_input_registers = read_.read_input_registers_float(start_address=start_address_input_registers, count= count_input_registers)
        data_holding_registers = read_.read_holding_registers_float(start_address=start_address_holding_registers, count= count_holding_registers)

    data = data_coil +'-'+data_discrete_input+'-'+data_input_registers+'-'+data_holding_registers+'-'+"\r\n"
    ser.write(data.encode())
    ser.flush()
    time.sleep(0.6)